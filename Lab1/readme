# 1) Общая архитектура программы (что за модуль, как он работает)

Код реализует **упрощённый двухпроходный ассемблер** с графическим интерфейсом (Windows Forms). Главные компоненты:

* `Form1` — форма с элементами UI (текстовые поля для исходного текста и таблицы кодов операций, DataGridView для вспомогательной таблицы и таблицы символов, ListBox для объектного кода и т.д.). Кнопка 1 запускает первый проход, кнопка 2 — второй проход. (см. `Form1`, `button1_Click`, `button2_Click`). 

* `Core` — центральный объект, хранящий состояние ассемблера: таблицы, текущие адреса, сообщения об ошибках, методы-помощники (поиск метки, парсер исходника и т.д.). В `Core` определены две основные структуры:

  * `SupportTable` — вспомогательная таблица (используется для передачи информации между первым и вторым проходом).
  * `SymbolNameTable` — таблица символических имен (меток): два списка — имена и соответствующие им адреса в шестнадцатеричной строке (по 6 знаков). 

* `FirstPass` — реализация **первого прохода**: проверка исходного текста и ТКО (таблицы кодов операций), вычисление адресов, заполнение `SupportTable` и `SymbolNameTable`, накопление значений адреса (LOCCTR в терминах классических ассемблеров). 

* `SecondPass` — реализация **второго прохода**: на основе `SupportTable` и `SymbolNameTable` формирует записи объектного модуля (заголовок H, тело T, запись конца E), проверяет корректность операндов, формирует машинную последовательность (в текстовом, читабельном виде). 

* `TypeCheck` / `TypeConverter` — утилиты: проверка типов строк/операндов/регистров, преобразования между десят. и 16-ричным форматами, формирование строк-записей (H/T/E), перевод символьных констант C"..." в ASCII, парсеры и пр. 

Важное об расположении данных: `SupportTable` — это список из 4 списков (`List<List<string>>`), каждая подсписок — столбец. В разный момент (особенно для первой строки START) код складывает в эти колонки разные типы информации — об этом ниже (важный нюанс).

# 2) Парсинг исходного текста и ТКО

* Метод `Core.ParseTextBox(TextBox txt, int columnCount)` — разбирает содержимое многострочного TextBox (поддерживает токены типа `C"..."` и `X"..."`, учитывает наличие/отсутствие метки в начале строки по ведущему пробелу). Он возвращает двумерный массив `string[,]` размером (#строк × columnCount). Это общий и достаточно аккуратный парсер, который:

  * извлекает токены (регулярным выражением),
  * если строка начинается с пробела — предполагает отсутствие метки (тогда первый токен — MKOP),
  * если строка не с пробела — первый токен считается меткой. 

Нюанс: парсер приводит все токены (кроме C"..."/X"..." строк) в `ToUpperInvariant()` — значит имена команд/меток нормализуются в верхний регистр.

# 3) Что такое ТКО (таблица кодов операций) и проверка её корректности

* В программе ТКО — это тоже текстовая таблица (в `txtOperCode`). Формат строчки ТКО: `ИМЯ` `МКОП` `РАЗМЕР` (3 колонки). Пример, который загружается по умолчанию:

  ```
  JMP     01   4
  LOADR1  02   4
  ADD     04   2
  SAVER   05   4
  INT     06   1
  ```
* Метод `Core.CheckOperationCodeTable` проверяет:

  * что все поля не пустые, адекватной длины;
  * что поле МКОП — корректная 16-ричная строка и уникальна среди команд;
  * что поле РАЗМЕР — число и принадлежит множеству {1,2,4}.
* Если проверка не проходит — в `Core.ErrorMessage` заносится ошибка. 

# 4) Первый проход (`FirstPass`)

**Цели первого прохода:**

* определить адреса всех исходных операторов (LOCCTR),
* собрать таблицу символов (меток) — `SymbolNameTable`,
* сформировать `SupportTable`, с которым второй проход будет работать.

**Алгоритм (детали):**

1. Инициализация: `AddressCount = 0`, `StartAddress = 0`, создаются пустые списки в `SupportTable` и `SymbolNameTable`.

2. Проверка первой строки — `IsFirstStart`: первая строка должна быть `LABEL START <address>`. ВАЖНО: в реализации `START` ожидает **десятичный** адрес — проверка делает `int.TryParse(opr1, out number)`. Если всё ок — `CORE.AddressCount = number; CORE.StartAddress = number;` и в `SupportTable` для первой строки добавляется запись особого вида: `CORE.AddStringToSupportTable(label, command, TypeConverter.ToSixChars(TypeConverter.DecToHex(number)), "");`. (То есть для первой строки программа кладёт в `SupportTable[0]` — **имя программы**, в `SupportTable[1]` — слово `"START"`, в `SupportTable[2]` — стартовый адрес в 6-значном hex.) Это важное отличие от обычных строк — далее код специально учитывает, что первая строка — START. 

3. Для каждой строки (после START) `GetRow` извлекает `label`, `command` (MKOP), `opr1`, `opr2`, делает базовую валидацию форматов.

4. Если есть метка (`label != ""`) и `StartFlag == 1` (т.е. START уже встретился), то метка сразу добавляется в `SymbolNameTable` со значением текущего `CORE.AddressCount`. То есть метка получает адрес на момент её встретки (как и должно быть).

5. Если `MKOP` — **директива** (`WORD`, `BYTE`, `RESB`, `RESW`, `END`), вызывается `DirectiveWork`:

   * `WORD` — резервирует/записывает 3 байта: если `Operand1` — число, записывает его (плюс поддержка `?` — необозначенное значение), увеличивает `AddressCount += 3`.
   * `BYTE` — обрабатывается как:

     * число 0..255 → 1 байт
     * `C"..."` → символы ASCII, длина = число байт
     * `X"..."` → hex-последовательность, длина должна быть чётной (каждые 2 hex-символа = 1 байт)
     * `?` → зарезервировать 1 байт
   * `RESB` — резервирует указанное количество байт (`AddressCount += n`).
   * `RESW` — резервирует n слов (по 3 байта): `AddressCount += 3*n`.
   * `END` — задаёт точку входа (EndAddress) и завершение первого прохода.
   * Для каждой директивы FirstPass добавляет в `SupportTable` строку с текущим адресом и деталями (см. код). 

6. Если `MKOP` — не директива (т.е. команда), происходит `CommandWork`:

   * Поиск команды в `arr_CodeTable` (ТКО), извлечение размера команды `arr_CodeTable[num,2]` и «МКОП» — `arr_CodeTable[num,1]`.
   * Для каждой длины команды реализована логика проверки операндов и обновления `AddressCount`:

     * **size = 1**: простая команда без операндов (например `INT` у вас) → `AddressCount += 1`. В `SupportTable` заносится текущий адрес и код адресации, операнды пустые. Код адресации формируется как `AddressationType = HexToDec(MKOP) * 4`. (см. ниже про формат.)
     * **size = 2**: команда 2 байта, возможные формы:

       * непосредственное значение (INT 200) — `Operand1` как число 0..255 → сохраняется `Operand1` в SupportTable, `AddressCount += 2`.
       * регистра-регистр (`R1, R2`) — оба операнда регистры → оба в SupportTable, `AddressCount += 2`.
       * иначе ошибка.
     * **size = 4**: адресная команда: `Operand1` должен быть меткой или число (но реализация запрещает, если `Operand1` — регистр/директива/имя команды) — `AddressationType = HexToDec(MKOP)*4 + 1` (заметьте `+1`), `AddressCount += 4`. Второй операнд обычно игнорируется (и программа предупреждает). 

7. После прохода `SupportTable` и `SymbolNameTable` переносятся в `DataGridView` на форме, а ошибки печатаются в `tbErrorOnePass`.

**Ключевой нюанс**: для первой строки START `SupportTable` хранит (label, MKOP, address), а для обычных машинных/директивных строк — обычно `(address, MKOP, operand1, operand2)`. Это смешивание форматов — код во втором проходе учитывает это специальной веткой (`if (i == 0) ...`) — имейте это в виду при понимании структуры. 

# 5) Второй проход (`SecondPass`)

**Цели второго прохода:**

* Пройти по `SupportTable`, проверить операнды окончательно (существуют ли метки, корректны ли константы, корректны строки C"..." / X"..."),
* Сформировать текстовое представление объектного модуля в упрощённом формате с H/T/E записями (и в `BinaryCode` ListBox добавлять записи).

**Как формируется объектный модуль:**

* **H (Header)**: первая запись формируется особым образом (i==0):

  ```csharp
  TypeConverter.EditingString("H",
     CORE.SupportTable[0][0], CORE.SupportTable[2][0],
     "", Convert.ToString(CORE.AddressCount - CORE.StartAddress), "");
  ```

  Поскольку `SupportTable[0][0]` = имя программы (label в START), а `SupportTable[2][0]` = стартовый адрес (в виде 6-символьного hex), итоговая H-строка будет: `H  <progname>  <startaddr>  <prog_length (6-hex)>`.
  Длина программы = `CORE.AddressCount - CORE.StartAddress`. 

* **T (Text) записи**: для каждой строки (кроме первой) создаётся T-запись. Логика:

  * Если строка — директива `RESB/RESW/BYTE/WORD`, формируется T-запись, в которой поле `command` обычно пустое (MKOP="") — но длина и содержимое рассчитываются по правилам директив (особенно важно: `RESB`/`RESW` — для них в записи кладут только адрес, длину = 0? в коде MKOP становится пустым, и в EditingString передаются длина и содержимое).
  * Если строка — команда, то сначала `CheckingOperandSecondPass` вызывается для каждого операнда:

    * Если операнд — метка: возвращается её адрес из `SymbolNameTable`.
    * Если операнд — регистр: возвращается номер регистра, преобразованный в hex (через `DecToHex`).
    * Если операнд — десятичное число: возвращается двузначный hex `ToTwoChars(DecToHex(number))`.
    * Если операнд — `C"..."` → конвертируется в ASCII hex (`ToASCII`).
    * Если операнд — `X"..."` → возвращается содержимое как есть (hex).
    * Если операнд — `"?"` → возвращается пустая строка (неинициализировано).
    * В случае ошибки (операнд не распознан) — ошибка.
  * Для команд определяется длина записи: `RecordLength = ToTwoChars(DecToHex((MKOP.Length + result1.Length + result2.Length)/2))`. Здесь `MKOP` — строка с кодом адресации, `result1/result2` — hex-представления операндов; сумма длин делится на 2 (число байт), потом переводится в hex два знака.
  * T-запись собирается через `TypeConverter.EditingString("T", address, MKOP, RecordLength, result1, result2)` — и добавляется в `BinaryCode` ListBox. 

* **E (End)**: в конце создаётся запись `E  <entry point 6-hex>`. В `SecondPass` это:

  ```csharp
  TypeConverter.EditingString("E", ToSixChars(DecToHex(CORE.EndAddress)), "", "", "", "");
  ```

Таким образом программа формирует упрощённый текстовый вариант объектного модуля: H/T/E записи в удобочитаемом формате.

# 6) Формат и смысл поля «МКОП» / AddressationType (важный нюанс)

В вашей реализации ТКО хранит поле МКОП — hex код, например `01`, `02`, `04` и т.д. Но при формировании записи в `SupportTable` код немного преобразуется:

* В `CommandWork` для size=1/2:

  ```csharp
  AddressationType = HexToDec(arr_CodeTable[num,1]) * 4;
  ```
* Для size=4:

  ```csharp
  AddressationType = HexToDec(arr_CodeTable[num,1]) * 4 + 1;
  ```

Далее `AddressationType` снова переводится в 2-символьную hex-строку и кладётся в `SupportTable[1]`.

Во **втором проходе** при проверке допустимости типов адресации читается:

```csharp
int Type_of_adr = (byte)TypeConverter.HexToDec(MKOP) & 0x03;
if (Type_of_adr == 1) { /* прямая - требуется метка и только один операнд */ }
```

То есть низкие 2 бита (биты 0–1) кода адресации используются для указания режима адресации:

* если `Type_of_adr == 1` → код указывает на **прямую** (непосредственную?) адресацию, и программа **требует**, чтобы операнд был меткой и чтобы **второго операнда не было**.
* Для других значений низких битов допускаются регистры, числа, строки и т.д.

Вывод: код МКОП в ТКО используется как база (умножается на 4), а добавка `+1` для 4-байтных команд устанавливает в младших битах флаги адресации. Точные значения флагов не документированы в коде, но логика проверок показывает: низкие 2 бита кодируют тип адресации. Это нестандартно по сравнению, например, с форматом SIC/XE, но для учебной цели — рабочая схема. 

# 7) Обработка операндов во втором проходе — `CheckingOperandSecondPass`

Подробности (важно понять, что именно возвращается):

* Если операнд — метка (есть в `SymbolNameTable`) → возвращается **адрес метки** (шестизначный hex, т.к. в SymbolNameTable адрес хранится как `ToSixChars(DecToHex(addr))`).
* Если операнд — регистр (`R0`…`R15`) → возвращается `DecToHex(regnum)` (номер регистра в hex).
* Если операнд — десятичное число → возвращается `ToTwoChars(DecToHex(number))` (один байт, 2 hex-символа).
* Если операнд — `C"..."` → возвращается ASCII-hex последовательность (`ToASCII`).
* Если операнд — `X"..."` → возвращается сама hex-строка (проверяется на корректность).
* Если операнд — `"?"` → возвращается `""` (пусто).
* Если ни одно — `error = 1` и будет записана ошибка. 

# 8) Пример пошагово (всё, что у вас по умолчанию в `Form1_Load`)

В `Form1_Load` у вас есть пример исходника и ТКО. Я пройдусь по нему и покажу, какие адреса/таблицы формируются (все арифметические вычисления я делаю пошагово здесь, именно так выполнится ваш FirstPass / SecondPass).

Исходный текст (`txtSource`) — строки (пронумерую для удобства; первые три поля: [LABEL] [MKOP] [OP1] [OP2]):

0. `PROG    START   100`
1. `        JMP     L1`
2. `A1      RESB    10`
3. `A2      RESW    20`
4. `B1      BYTE    C"Hello World!"`
5. `        BYTE    X"5A2F016A"`
6. `        BYTE    12`
7. `B2      WORD    40`
8. `L1      LOADR1  B2`
9. `        ADD     R1    R2`
10. `        SAVER  A2`
11. `        INT     `
12. `        END     100`

ТКО (`txtOperCode`):

```
JMP     01   4
LOADR1  02   4
ADD     04   2
SAVER   05   4
INT     06   1
```

**А теперь адреса и таблицы (в десятичной и hex форме):**

* START: `PROG`, стартовый адрес = **100 (десятич)**. Поэтому `AddressCount = StartAddress = 100`.

1. `JMP L1`:

   * Команда `JMP` имеет МКОП `01`, размер 4.
   * Для size=4: `AddressationType = HexToDec("01")*4 + 1 = 1*4 + 1 = 5` → hex `05`.
   * Текущий адрес (для этой инструкции) = **100 dec** = hex `0x64`.
   * Добавляется запись в `SupportTable`: адрес `000064`, MKOP(адресации) `05`, operand1 `L1`, operand2 `""`.
   * `AddressCount += 4` → **104**. 

2. `A1 RESB 10`:

   * Есть метка `A1` — добавляется в `SymbolNameTable` со значением текущего `AddressCount` = **104** → `0x68` → `"000068"`.
   * `RESB 10` резервирует 10 байт, в `SupportTable` добавляется запись: адрес `000068`, MKOP `RESB`, operand1 `"10"`.
   * `AddressCount += 10` → **114**.

3. `A2 RESW 20`:

   * Метка `A2` → `SymbolNameTable` получает `114` → hex `0x72` → `"000072"`.
   * `RESW 20` резервирует `20 * 3 = 60` байт.
   * `SupportTable` запись: адрес `000072`, MKOP `RESW`, operand1 `"20"`.
   * `AddressCount += 60` → **174**.

4. `B1 BYTE C"Hello World!"`:

   * Метка `B1` → `SymbolNameTable` получает `174` → hex `0xAE` → `"0000AE"`.
   * `C"Hello World!"` → длина 12 байт (символы) → `AddressCount += 12` → **186**.
   * `SupportTable` запись: адрес `0000AE`, MKOP `BYTE`, operand1 `C"Hello World!"`.

5. `BYTE X"5A2F016A"`:

   * X-строка длина 8 hex символов → 8/2 = 4 байта → `AddressCount += 4` → **190**.
   * `SupportTable` запись: адрес `0000B A ?` (точно `ToSixChars(DecToHex(186))` для предыдущ entry; но текущая запись адреса для этой строки будет `TypeConverter.ToSixChars(TypeConverter.DecToHex(186))` при добавлении — в любом случае адресы последовательны).

6. `BYTE 12` — число 12 → 1 байт → `AddressCount += 1` → **191**.

7. `B2 WORD 40` — метка `B2` получает адрес **191** (hex `0xBF` → `"0000BF"`). `WORD 40` — 3 байта → `AddressCount += 3` → **194**.

8. `L1 LOADR1 B2` — метка `L1` получает адрес **194** (hex `0xC2` -> `"0000C2"`). `LOADR1` `02` size=4 ⇒ AddressationType = 2*4 +1 = 9 (hex `09`). `AddressCount += 4` → **198**.

9. `ADD R1 R2` — команда size=2, оба операнда регистры → AddressationType = 4*4 = 16 (hex `10`). Текущий адрес **198** (hex `C6`). `AddressCount += 2` → **200**.

10. `SAVER A2` — `SAVER` `05` size=4 ⇒ AddressationType = 5*4 +1 = 21 (hex `15`). Адрес **200** (hex `C8`). `AddressCount += 4` → **204**.

11. `INT` — размер 1, `INT` `06` ⇒ AddressationType = 6*4 = 24 (hex `18`). Адрес **204** (hex `CC`). `AddressCount +=1` → **205**.

12. `END 100` — задаёт `EndAddress = 100` (в коде END парсит как число, проверяет, что `EndAddress` лежит между `StartAddress` и `AddressCount`). Всё корректно: `100 >= 100 && 100 <= 205`.

Итог: `StartAddress = 100`, `AddressCount = 205` ⇒ **длина программы = 205 - 100 = 105** (`0x69`).

Во втором проходе вы получите:

* H-запись: `H  PROG  000064  000069` (имя, стартовый адрес, длина). (Фактический формат печати зависит от `EditingString`, но смысл такой.)
* T-записи для каждой строки с адресом, длиной записи и содержимым (MKOP + операнды в hex).
* E-запись: `E  000064` (точка входа — EndAddress). 

# 9) Структура `SupportTable` — ещё раз, и где ловушки

По коду видно, что `SupportTable` — это `List<List<string>>` с 4 «столбцами». Но значения этих столбцов **неоднородны**:

* Для **первой строки (START)** `AddStringToSupportTable(label, command, ToSixChars(startAddr), "")` =>

  * `SupportTable[0][0]` = **имя программы** (label)
  * `SupportTable[1][0]` = `"START"`
  * `SupportTable[2][0]` = **стартовый адрес (6-hex)**
  * `SupportTable[3][0]` = `""`
* Для **обычных инструкций** `AddStringToSupportTable(ToSixChars(address), ToTwoChars(AddressationType), operand1, operand2)` =>

  * `SupportTable[0][i]` = **адрес инструкции (6-hex)**
  * `SupportTable[1][i]` = **код адресации / MKOP-поле (2-hex)**
  * `SupportTable[2][i]` = **операнд1 (строка: может быть число, регистр, метка, C"", X"" и т.д.)**
  * `SupportTable[3][i]` = **операнд2**

Из-за этой несимметрии в коде второго прохода есть специальная проверка `if (i == 0)` — для формирования H-записи. Это нормально, но при модификации кода нужно быть осторожным: логика доступа к `SupportTable` зависит от индекса строки.

# 10) Ошибки, баги и места, которые можно улучшить (важно знать)

В коде есть несколько мест, на которые следует обратить внимание (и которые лучше исправить/улучшить для надёжности):

1. **Формат адреса START — вводится как десятичный** (`int.TryParse` у `IsFirstStart`). Это легко запутывает: обычно в ассемблерах адреса часто задаются в hex. Рекомендация — либо однозначно документировать, либо позволить `0x`/`$` префиксы, либо пробовать парсить hex при отсутствии `int.TryParse`.

2. **Непоследовательность в структуре `SupportTable`** — как описано выше. Это не критично сейчас, но затрудняет расширения (например добавление EXTDEF/EXTREF из этапа 3).

3. **Некоторые функции реализованы неэффективно или с потенциальными логическими мелкими багами**:

   * `TypeConverter.DecToHex` — реализация деления в цикле несколько небрежна (логика цикла использует `tempNumber` и `decNumber` немного запутанно). В большинстве случаев будет работать, но лучше заменить на `decNumber.ToString("X")` (в .NET) для корректности и простоты.
   * `TypeCheck.IsRegister` реализована через цикл и внутри `Array.IndexOf(reg, str)` — по сути работает, но код можно упростить в одну строчку `return Array.IndexOf(reg, str) != -1;`. Сейчас цикл бессмысленный, но работает.
   * `TypeConverter.ToTwoChars` и `ToSixChars` — реализованы вручную; но если входная `number == ""` — возвращают `""`, что учитывается во многих местах. Хорошо бы унифицировать форматирование.

4. **Обработка ошибок** — ошибки записываются в `CORE.ErrorMessage` и выводятся в `TextBox`, но в случае ошибок второй проход очищает `BinaryCode.Items` и возвращает `true`/`false` по-разному. Можно структурировать возвращаемые коды и исключения для большей прозрачности.

5. **Международные форматы и регистры** — Поскольку парсер переводит команды в upper-case, но при сравнении директивы `TypeCheck.IsDirective` использует `ToUpper`, тут всё в порядке. Но при загрузке ТКО важно чтобы пользователь ввёл корректные значения. В `CheckOperationCodeTable` проверяется, что МКОП < 0x3F (то есть 63), это ограничение заложено жестко.

6. **Нельзя проверить EXTREF/EXTDEF и загрузку/перемещения/сборку объектного файла в формате, указанном в Этапе 2/3** — в текущем коде нет реализации EXTREF/EXTDEF и таблицы настройки/внешних ссылок; это — будущие шаги задания, сейчас поддержано только базовое формирование H/T/E и базовые директивы. (Вы видите места, где это нужно расширить.)

# 11) Где и как программа выводит результаты (UI)

* После успешного первого прохода `FirstPass` заполняет `dataGrid_supportTable` (вспомогательная таблица) и `dataGrid_symbol_table` (таблица символов). Ошибки первого прохода печатаются в `tbErrorOnePass`.
* После запуска второго прохода `SecondPass.SecondPassFunc` заполняет `tbBinaryCode` (ListBox) записями H/T/E и пишет ошибки во `tbErrorTwoPass`.
* Кнопка второго прохода (`button2`) включается только после успешного первого прохода (`button2.Enabled = true`), чтобы пользователь не запустил второй проход по пустым таблицам. 

# 12) Поддерживаемые команды и директивы (список)

Из кода явственно поддерживаются (директивы и примеры из ТКО):

**Директивы (система):**

* `START` — задаёт имя программы и стартовый адрес (ожидается десятичное число).
* `END` — задаёт адрес точки входа (если указан).
* `BYTE` — поддерживает три формы: число (0..255), `C"..."`, `X"..."`, и `?`.
* `WORD` — 3-байтовое целое; поддерживает число (>=0) и `?`.
* `RESB` — зарезервировать n байт.
* `RESW` — зарезервировать n слов (каждое 3 байта).

**Команды (пример из `txtOperCode`):**

* `JMP` (opcode `01`, size 4)
* `LOADR1` (`02`, size 4)
* `ADD` (`04`, size 2)
* `SAVER` (`05`, size 4)
* `INT` (`06`, size 1)

(Это список из примера. На самом деле набор команд — тот, что вы загрузите в `txtOperCode` — программа проверит валидность и использует их.)

# 13) Примеры ошибок и предупреждений, с которыми можно столкнуться

* Повторяющаяся метка → ошибка и завершение.
* Плохой формат строки исходного кода → синтаксическая ошибка.
* МКОП не найден в ТКО → ошибка.
* В директивах: некорректный аргумент (например, `BYTE X"ABC"` — нечетное число hex символов) → ошибка.
* Выход за границы памяти (максимальный адрес `16777215` — 0xFFFFFF) → ошибка.
* Если первый проход ещё не был выполнен, то запуск второго — сообщение: "Выполните первый проход".
* В командах: неверный тип операндов для данного размера команды → ошибка (например, если команда size=2 ожидает либо два регистра, либо число, а получает метку/неправильный тип) — см. `CommandWork`. 

# 14) Что можно улучшить / расширить (рекомендации для следующего этапа)

* **Ясность форматов**: привести START/END к единому hex-формату (или добавить поддержку hex-писем, например `$100` или `0x64`) — сейчас только decimal.
* **Унифицировать `SupportTable`**: сделать структуру с явными полями (класс `SupportRow` с полями `IsStart`, `Address`, `Opcode`, `Operand1`, `Operand2`) вместо `List<List<string>>` — это упростит чтение и поддержку.
* **Разделить логику кодогенерации**: сейчас второй проход формирует T-записи и содержимое прямо строками; лучше выделить генерацию байт-кода (в виде `byte[]` или `List<byte>`) и отдельно форматирование в H/T/E.
* **Реализовать этапы 2–3**: таблицу настройки (relocation), EXTDEF/EXTREF, проверку внешних ссылок, сохранение объектного кода в текстовом файле в полном перемещаемом формате — для этого нужно:

  * добавить новые колонки в `SupportTable`/UI для фиксации имен внешних ссылок;
  * в первом проходе обрабатывать `EXTDEF` / `EXTREF` (помечать имена и ссылки);
  * во втором проходе формировать таблицу настройки и список внешних ссылок, а также корректно оформлять вывод.
* **Тесты**: добавить набор автоматических тестовых исходников (unit tests) для граничных случаев (BYTE X odd length, RESB 0, повтор метки, START с 0 и т.п.).
* **Корректная работа с hex-конвертацией**: заменить ручные реализации на встроенные средства .NET (`int.Parse(..., NumberStyles.HexNumber)`, `value.ToString("X")`, `PadLeft`) — уменьшит риск ошибок в конвертации. 

# 15) Краткая итоговая «инструкция» как читать/понимать программу (практическая)

1. Открой `txtOperCode` — это ваш ТКО (определяет имена команд, их «машинный» код и размер в байтах). Убедись, что МКОП — корректный hex и что размер — 1/2/4.
2. Открой `txtSource` — это исходный ассемблерный текст (метки, команды, директивы). Формат строки: `[LABEL] MKOP [OP1] [OP2]`. Либо строка может начинаться с пробела — тогда метки нет.
3. Нажми кнопку 1 — это запустит `FirstPass`: она создаст `SupportTable` и `SymbolNameTable`, вычислит адреса и проверит синтаксис. Ошибки отобразятся в `tbErrorOnePass`.
4. Если первый проход успешен — нажми кнопку 2 — `SecondPass` соберёт H/T/E записи и выведет их в `tbBinaryCode` (а ошибки — в `tbErrorTwoPass`).
5. Если нужно расширить функциональность (EXTREF, релокация и т.д.) — работать надо в `FirstPass` (парсинг псевдооператоров) и `SecondPass` (формирование таблиц перенастройки/внешних ссылок).

# 16) Ещё несколько технических замечаний (чтобы вы не запутались)

* `TypeConverter.EditingString("T", address, command, length, operand1, operand2)` объединяет данные в читабельную T-запись: `T  <addr>  <length>   <command><operand1><operand2>`. Для директив (например `BYTE`) `command` в объектном коде заменяют на пустую строку, а `operand1/2` несут полезную hex-данные.
* Во многих местах код хранит адреса как **строки hex** с разной шириной: иногда 2 hex-символа (`ToTwoChars`), иногда 6 (`ToSixChars`). Это важно учитывать, когда вы будете сравнивать/сортировать/фильтровать данные.
* `Core.FindCodeInCodeTable` ищет по имени команды в `arr_CodeTable` (ТКО) и возвращает индекс; если -1 — команда не найдена (ошибка).
* В `TypeCheck.ByteString` проверяется корректность X"..." — символы внутри должны быть hex.


